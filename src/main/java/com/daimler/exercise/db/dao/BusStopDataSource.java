package com.daimler.exercise.db.dao;

import com.zaxxer.hikari.HikariDataSource;
import lombok.extern.log4j.Log4j;
import org.jooq.*;
import org.jooq.exception.DataAccessException;
import org.jooq.impl.DSL;

import java.math.BigDecimal;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Set;
import java.util.function.Function;

import static com.daimler.exercise.db.autogenerated.tables.BusStop.BUS_STOP;
import static org.jooq.impl.DSL.trueCondition;

/**
 *  Uses jOOQ to extract data from the database
 */
@Log4j
public class BusStopDataSource {

    private final HikariDataSource dataSource;

    public BusStopDataSource(final HikariDataSource dataSource) {
        this.dataSource = dataSource;
    }

    public List<String> findAllOperatorsByTimestamp(long epochTimeStart, long epochTimeEnd) throws DataAccessException {
        try (final DSLContext ctx = DSL.using(dataSource, SQLDialect.POSTGRES)) {
            return ctx.
                    select(BUS_STOP.OPERATOR).
                    from(BUS_STOP).
                    where(BUS_STOP.TIMESTAMP.between(epochTimeStart, epochTimeEnd)).
                    groupBy(BUS_STOP.OPERATOR).
                fetch(BUS_STOP.OPERATOR);
        }
    }

    public List<Integer> findAllVehiclesIdByTimestampAndOperatorAndAtStop(Long epochTimeFrom, Long epochTimeTo, String operator, Boolean atBusStop) {
        try (final DSLContext ctx = DSL.using(dataSource, SQLDialect.POSTGRES)) {
            return ctx.
                    select(BUS_STOP.VEHICLE_ID).
                    from(BUS_STOP).
                    where(onlyIfNotNull(BUS_STOP.AT_BUS_STOP::eq, atBusStop)).
                        and(BUS_STOP.TIMESTAMP.between(epochTimeFrom, epochTimeTo)).
                        and(BUS_STOP.OPERATOR.equalIgnoreCase(operator)).
                    groupBy(BUS_STOP.VEHICLE_ID).
                fetch(BUS_STOP.VEHICLE_ID);

        }
    }

    private static <T> Condition onlyIfNotNull(Function<T, Condition> operator, T value) {
        return (value != null) ? operator.apply(value) : trueCondition();
    }

    public Set<String> findAllTracesByVehicleOrderedByTimestamp(Long epochTimeFrom, Long epochTimeTo, Integer vehicleId) {
        try (final DSLContext ctx = DSL.using(dataSource, SQLDialect.POSTGRES)) {
            Set<String> gpsEntries = new LinkedHashSet<>();
            ctx.
                select(BUS_STOP.LATITUDE, BUS_STOP.LONGITUDE).
                from(BUS_STOP).
                where(BUS_STOP.VEHICLE_ID.eq(vehicleId)).
                    and(BUS_STOP.TIMESTAMP.between(epochTimeFrom, epochTimeTo)).
                orderBy(BUS_STOP.TIMESTAMP).
            fetchInto( (RecordHandler<Record2<BigDecimal, BigDecimal>>) record -> {
                BigDecimal latitude = record.getValue(BUS_STOP.LATITUDE);
                BigDecimal longitude = record.getValue(BUS_STOP.LONGITUDE);
                gpsEntries.add(latitude.toString().concat(" : ").concat(longitude.toString()));
            });
            return gpsEntries;
        }
    }
}
